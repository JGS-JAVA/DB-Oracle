--그룹별로 조회 
SELECT DEPT_CODE,SUM(SALARY),AVG(SALARY) FROM EMPLOYEE E GROUP BY DEPT_CODE ;

SELECT DEPT_CODE,SUM(SALARY),FLOOR(AVG(SALARY)),COUNT(*) AS 사원수
FROM EMPLOYEE
GROUP BY DEPT_CODE
ORDER BY DEPT_CODE;

SELECT COUNT(BONUS) FROM EMPLOYEE ORDER BY DEPT_CODE ASC;

--– 1. EMPLOYEE 테이블에서 부서코드가 'D5', 'D6'인 부서의 평균 급여 조회
--UPPER 문자열 하나 변환가능, 다중값 불가
SELECT DEPT_CODE,FLOOR(avg(SALARY)) AS 평균급여 FROM EMPLOYEE 
WHERE DEPT_CODE IN ('D5' , 'D6') GROUP BY DEPT_CODE;
--– 2. EMPLOYEE 테이블에서 직급 별 2000년도 이후 입사자들의 급여 합을 조회
------ WHERE EXTRACT(YEAR FROM HIRE_DATE) -- 날짜에서 연도만 가져오기
SELECT JOB_CODE,SUM(SALARY) FROM EMPLOYEE 
WHERE EXTRACT(YEAR FROM HIRE_DATE) >= 2000 
GROUP BY JOB_CODE;
--– 3. EMPLOYEE 테이블에서 부서 별로 같은 직급인 사원의 급여 합계를 조회하고
---- 부서 코드 오름차순으로 정렬
--SUM, AVG 계산결과만 볼땐 GROUP BY 안써도 됨
--SUM, AVG 계산결과와 다른 컬럼명 같이 볼땐 GROUP BY 써야 됨
SELECT DEPT_CODE, 
FROM EMPLOYEE
--– 4. EMPLOYEE 테이블에서 부서 별로 급여 등급이 같은 직원의 수를 조회하고
---- 부서코드, 급여 등급 오름차순으로 정렬
SELECT DEPT_CODE, SAL_LEVEL, COUNT(*) FROM EMPLOYEE
GROUP BY DEPT_CODE, SAL_LEVEL
--부서코드로 정렬후, 부서 안에서 급여레벨로 정렬 
ORDER BY DEPT_CODE, SAL_LEVEL
--– 5. EMPLOYEE 테이블에서 부서코드와 부서별 보너스를 받는 사원의 수를 조회하고
------ 부서코드 오름차순 정렬
SELECT DEPT_CODE, COUNT(*) FROM EMPLOYEE WHERE BONUS IS NOT NULL 
GROUP BY DEPT_CODE ORDER BY DEPT_CODE;
--– 6. EMPLOYEE 테이블에서 부서코드와 부서별 보너스를 받는 사원의 수를 조회하고
------ 부서코드 오름차순 정렬 null 인 행 빼고 카운트
SELECT DEPT_CODE, COUNT(BONUS) FROM EMPLOYEE WHERE BONUS IS NOT NULL
GROUP BY DEPT_CODE ORDER BY DEPT_CODE;

--EMPLOYEE 테이블과 DEPARTMENT 테이블에서 부서코드 조회
SELECT * FROM EMPLOYEE;
SELECT * FROM DEPARTMENT;

SELECT employee.emp_id, employee.EMP_NAME, 
employee.DEPT_CODE, department.DEPT_TITLE  
FROM EMPLOYEE, DEPARTMENT
WHERE employee.DEPT_CODE = department.DEPT_ID;

SELECT e.EMP_ID,e.EMP_NAME,e.JOB_CODE,n.job_name 
FROM EMPLOYEE e, job n;

SELECT d.DEPT_ID,d.DEPT_TITLE,d.LOCATION_ID, l.local_name
FROM DEPARTMENT d, LOCATION l;

--d , l 을 변수처럼 쓴다

SELECT D.DEPT_ID, D.DEPT_TITLE, D.LOCATION_ID, 
L.LOCAL_CODE, N.NATIONAL_NAME
FROM DEPARTMENT D, LOCATION L, NATIONAL N
--WHERE절 필수사용 = 서로 같다는 표기 2개 이상의 표에서 쓸때
WHERE D.LOCATION_ID = L.LOCAL_CODE
AND L.LOCAL_NAME = N.NATIONAL_CODE;

--
SELECT DEPT_CODE, FLOOR(AVG(SALARY)) AS "[평균 급여]"
FROM EMPLOYEE GROUP BY DEPT_CODE;
--
SELECT E.JOB_CODE, E.EMP_NAME, MAX(E.SALARY) AS "최고급여"
FROM EMPLOYEE E
GROUP BY E.JOB_CODE, E.EMP_NAME
ORDER BY E.JOB_CODE, MAX(E.SALARY) DESC;
--
SELECT DEPT_CODE, AVG(SALARY) AS 평균급여
FROM EMPLOYEE E
GROUP BY DEPT_CODE;
--
SELECT EMP_NAME
FROM EMPLOYEE E, DEPARTMENT D
WHERE D.DEPT_ID = E.DEPT_CODE
AND D.DEPT_TITLE = '인사관리부';

-- 1. 이메일 주소가 등록된 직원의 이름과 부서명을 출력하시오.
SELECT e.EMP_NAME, d.DEPT_TITLE FROM EMPLOYEE e, DEPARTMENT d
WHERE e.DEPT_CODE = D.DEPT_ID --생략가능
AND E.EMAIL IS NOT NULL;
-- 2. 각 부서의 최고 급여를 출력하시오.
SELECT EMP_NAME, DEPT_CODE max(salary) FROM EMPLOYEE 
GROUP BY DEPT_CODE, EMP_NAME;
ORDER BY DEPT_CODE, MAX(salary) DESC;
-- 2-1. 각 부서의 최고 급여를 출력하시오.
SELECT EMP_NAME, DEPT_CODE, salary FROM EMPLOYEE 
WHERE (DEPT_CODE,SALARY) IN (SELECT DEPT_CODE, MAX(SALARY)
FROM EMPLOYEE GROUP BY DEPT_CODE) ORDER BY DEPT_CODE;
-- 3. 각 급여 등급별 직원 수를 출력하시오.
SELECT SALARY, COUNT(*) AS 직원수 FROM EMPLOYEE 
GROUP BY SALARY;
-- 4. 부서 이름과 평균 급여를 급여가 높은 순으로 정렬 출력하시오.
SELECT DEPT_TITLE, SALARY AS 평균급여
FROM EMPLOYEE E, DEPARTMENT D
WHERE EMPLOYEE.DEPT_CODE = DEPARTMENT.DEPT_ID-- 생략가능
GROUP BY DEPT_TITLE 
ORDER BY AVG(SALARY) DESC;
-- 5. 지역별 부서 수를 출력하시오.
SELECT LOCATION_ID, --COUNT(DISTINCT 컬럼명) = 특정컬럼에서 중복값 제외한 행의 갯수반환
FROM DEPARTMENT
-- 6. 각 부서(DEPT_CODE)별 보너스 비율(BONUS)의 평균을 구하되, 평균 보너스 비율이 높은 순으로 정렬
SELECT DEPT_TITLE,AVG(SALARY) AS 평균급여, AVG(BONUS) AS 평균보너스
FROM EMPLOYEE, DEPARTMENT
GROUP BY DEPT_TITLE
ORDER BY DEPT_TITLE;

-- 7.각 부서(DEPT_CODE)별 평균 급여(SALARY)와 평균 보너스 비율(BONUS)을 조회하되, 부서명(DEPT_TITLE)을 기준으로 오름차순 정렬
SELECT 
FROM E 
-- 8. 각 부서별 퇴사자 수를 조회하고, 퇴사자 수가 많은 순으로 정렬
SELECT COUNT(*)
FROM EMPLOYEE E, DEPARTMENT D
WHERE ENT_YN = 'Y';
GROUP BY D.DEPT_TILTE

































